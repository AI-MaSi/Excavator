# Control algorithm configuration for excavator system
# Used by: ExcavatorController, PID controllers

rates:
  # Controller (IK) loop frequency in Hz
  control_hz: 200.0

imu:
  # IMU sampling rate (Hz) - Pico AHRS loop frequency
  sample_rate: 200
  # Gyroscope full-scale range (125/250/500/1000/2000 dps)
  gyro_dps: 500 # 500
  # AHRS filter gain (higher = faster response, more noise)
  ahrs_gain: 0.75 # 0.5
  # Accelerometer rejection threshold (degrees) - reject accel when orientation deviates
  accel_rejection: 10.0 #10.0
  # Recovery period (seconds) - time before re-enabling accel after rejection
  recovery_s: 0.5 #1.0
  # Gyro offset tracking timeout (seconds)
  offset_s: 0.5 # 1.0

pid:
  # PID controller gains for each joint
  # Joint 0: Slew (base rotation)
  joint0:
    kp: 2.0 #5.0
    ki: 0.250 #0.5
    kd: 0.0

  # Joint 1: Boom (lift arm)
  joint1:
    kp: 5.0
    ki: 0.1
    kd: 0.0

  # Joint 2: Arm (tilt)
  joint2:
    kp: 6.0
    ki: 0.1
    kd: 0.0

  # Joint 3: Bucket (scoop)
  joint3:
    kp: 5.0
    ki: 0.1
    kd: 0.0

controller:
  # PID output limits (normalized -1.0 to 1.0)
  output_limits_min: -1.0
  output_limits_max: 1.0

  # Joint velocity limiting (applied at IK level for cleaner architecture)
  # Set to False to disable velocity limiting entirely
  enable_velocity_limiting: true

  # Per-joint velocity limits in rad/iter [slew, boom, arm, bucket]
  # Formula: rad/iter = degrees/sec / (57.3 * control_hz)
  per_joint_max_velocity: [0.10, 0.25, 0.25, 0.25]


# Inverse Kinematics configuration
# Used by: ExcavatorController, IKController
ik:
  # Command type: "position" (3D) or "pose" (6D with orientation)
  command_type: "pose"

  # Whether commands are relative to current pose (delta commands)
  use_relative_mode: true

  # IK solving method: "pinv", "svd", "trans", or "dls" (damped least squares)
  method: "dls"

  # Velocity mode: interpret commands as desired EE velocities
  velocity_mode: true
  velocity_error_gain: 200.0  # Note: depends on hw/sim_dt!
  use_rotational_velocity: true

  # Method/weighting parameters
  # Note: k_val and lambda_val have decreased effect when velocity_mode is enabled,
  # as velocity_error_gain and per_joint_max_velocity dominate the response.
  params:
    # For pinv, svd, trans
    k_val: 5.0 # 1.15

    # For svd
    min_singular_value: 1.0e-5

    # For dls
    lambda_val: 0.01  # Base (min) value if adaptive damping is used

    # General
    position_weight: 1.0
    rotation_weight: 1.1  #1.1,  1.2 for delta position control
    joint_weights: [0.9, 1.0, 0.8, 1.0]  # [1.0, 1.0, 0.8, 1.0], [1.0, 1.0, 1.0, 0.8] for delta position control


  # Adaptive damping (DLS method only)
  # Adjusts lambda based on Jacobian condition number for better singularity handling.
  # Formula: lambda_adaptive = lambda_val * (1 + scaling * log(1 + condition_number))
  # Clamped to: lambda_val <= lambda_adaptive <= lambda_val * max_multiplier

  enable_adaptive_damping: true
  adaptive_damping_scaling: 0.5        # How aggressively lambda increases near singularities
  adaptive_damping_max_multiplier: 10.0  # Maximum lambda = lambda_val * max_multiplier

  # Relative-mode gains (applied to per-step delta pose when relative mode is enabled)
  relative_pos_gain: 1.0  # 1.0/3.0 irl/sim. Position delta control
  relative_rot_gain: 1.0

  # Axes to ignore in orientation error during IK solving.
  # Any combination of: roll, pitch, yaw
  # For excavator: roll is locked (hardware), yaw follows slew automatically.
  # User controls position (X,Y,Z) and pitch only.
  ignore_axes: ["roll", "yaw"]

  # Use reduced Jacobian (removes uncontrollable DOFs like roll)
  # Recommended for cleaner excavator control
  use_reduced_jacobian: true

  # Relative joint limits (degrees) for [slew, boom, arm, bucket]
  # Leave empty [] to use default [-π, π] for all joints
  # Example: [[-30.0, 30.0], [-45.0, 60.0], [-90.0, 90.0], [-90.0, 90.0]]
  joint_limits_relative: []

  # Joint weight scheduling - dynamically adjust joint weights based on EE position
  # Formula: scale = (r_nominal / clamp(r, r_min, r_max))^exponent
  # where r = sqrt(x² + y²) is horizontal radial distance from slew axis
  # At r_nominal: scale = 1.0 (base weight applies - set this to typical working distance)
  # At r < r_nominal: scale > 1.0 (more slew allowed when close)
  # At r > r_nominal: scale < 1.0 (less slew allowed when extended)
  joint_weight_scheduling:
    enabled: true
    joint0:  # slew
      r_min: 0.35          # clamp reach below this (m) - prevents extreme scaling
      r_max: 0.7          # clamp reach above this (m) - ~max working radius
      r_nominal: 0.5      # typical working distance where base weight applies
      exponent: 1.8       # power law (1.0 = linear, 2.0 = square)
